# Разработка метода и инструмента для анализа обфусцированного кода через проактивный мониторинг состояния кэш-памяти процессора

## Исходная проблема

Современная обфускация (Obfuscator-LLVM, Tigress, VM-протекторы) делает статический и динамический реверс инжиниринг программы либо невозможным, либо экономически нецелесообразным. Требуется принципиально иной подход к извлечению информации о логике защищенной программы.

## Ключевая идея

Использовать кэш процессора как высокочастотный сенсор активности программы. Обфускация может скрыть семантику инструкций, но не может устранить их физические следы при исполнении, то есть обращению к памяти и кэшу. Анализируя с высокой точностью паттерны этих обращений, мы можем восстановить поведенческий профиль программы, минуя слой обфускации.

---

## Суть метода: проактивное профилирование исполнения через кэши

Адаптировать классические атаки по сторонним каналам (Prime+Probe, Flush+Reload) в инструмент активного наблюдения. Непрерывно зондировать состояние общего кэша (LLC), строя временной профиль активности программы.

### **Конкретные цели и неопределенность результата**  
На данном этапе нет чёткого понимания конечного вида инструмента: это исследовательская работа. Есть набор мощных техник (Prime+Probe, Flush+Reload, Evict+Reload и др.) и гипотеза об их применимости для реверс-инжиниринга. В процессе разработки и экспериментов будет выясняться, какие комбинации методов дают наиболее полезные для анализа артефакты.

---

## Базовые методы работы с кэш-памятью для анализа исполнения

Основой инструмента станут адаптированные методы атак по сторонним каналам, перепрофилированные из средств атаки в средства наблюдения. Их объединяет использование кэша как разделяемого ресурса между целевой программой и анализатором.

**1. Prime+Probe (общий мониторинг)**

- **Prime (Заполнение):** Анализатор заполняет определенные наборы (sets) кэша L3 своими данными.
- **Исполнение:** Целевая программа выполняется короткий фиксированный интервал.
- **Probe (Зондирование):** Анализатор измеряет время доступа к своим данным. Значительное увеличение времени указывает, что целевая программа использовала эти кэш-линии, вытеснив данные анализатора.
- **Роль:** Построение общей временной диаграммы активности, выявление циклов и фаз выполнения.

**2. Flush+Reload (точечное отслеживание известных адресов)**

- **Flush (Сброс):** С помощью инструкции `CLFLUSH` анализатор вытесняет из кэша конкретную строку, соответствующую известному адресу (например, функции из разделяемой библиотеки).
- **Исполнение:** Запуск целевой программы.
- **Reload (Перезагрузка):** Анализатор измеряет время повторного чтения по тому же адресу. Короткое время доступа означает, что программа обратилась к этому адресу.
- **Роль:** Верификация гипотез, трассировка вызовов известных функций, обнаружение ветвлений.

**3. Evict+Reload и Evict+Time (альтернативы при недоступности CLFLUSH)**

- **Evict+Reload (Вытеснение+Перезагрузка):** Вытеснение строки кэша достигается не прямой инструкцией, а созданием конфликта адресации через заполнение соответствующего набора кэша.
- **Evict+Time (Вытеснение+Ожидание):** Анализ влияния вытеснения определенных кэш-линий на общее время выполнения целевой программы.
- **Роль:** Методы на случай, когда прямое управление кэшем затруднено или когда нужно оценить критичность определенной области кода для производительности.


### Фокус на кэш последнего уровня (L3)

В современных многоядерных процессорах кэши L1 и L2, как правило, приватны для ядра, что требует сложной синхронизации с планировщиком. L3 (LLC) является общим для всех ядер, что делает его более предсказуемой и стабильной средой для наблюдения.

---

## Потенциальные выходные артефакты (что может получиться в итоге)

1. **Heatmap (тепловая карта) активности или Flame graph** — базовый, но наглядный граф информации, показывающий, какие области кода (адресного пространства) были активны в течение выполнения.

2. **Граф потока исполнения (Control Flow Graph approximation)** — более высокоуровневая реконструкция, где узлы — это обнаруженные базовые блоки или функции, а рёбра — предполагаемые переходы между ними, выявленные по корреляции кэш-паттернов.

3. **Аннотированный дизассемблерный листинг** — где к статическому коду добавляются пометки о динамическом поведении, собранном через кэш.

**Фундаментальная и неизменная цель** - снижение энтропии и интеграция в процессе обратной разработки. Независимо от того, какой конкретно вид примет итоговый инструмент (набор скриптов, плагин для IDA, standalone-утилита), его миссия — преобразовать обфусцированную программу из "чёрного ящика" в объект с направлением для атаки. 

Он должен выдавать реверс-инженеру проверяемые гипотезы, например: "Вот этот блок, вероятно, содержит критическую проверку (длительная работа с последующим редким обращением к функции сравнения)". "Здесь вероятный анти-отладочный трюк (аномальное изменение кэш-паттерна при повторном прогоне)". Эти гипотезы позволят прицельно применять символическое выполнение, фаззинг или ручной анализ, радикально сужая область поиска.

---

## Технический фокус и сложности

**Ядро метода:** Точное измерение времени доступа к памяти (сайдинг-канал по времени) для картирования активности обфусцированной программы. Основное внимание на кэш последнего уровня (L3), как на общем для ядер ресурсе в современных многоядерных системах.

**Ключевые вызовы:**

1. **Подавление шума:** Борьба с влиянием ОС, планировщика, прерываний. Требуются статистические методы и, возможно, изоляция ядер.

2. **Переносимость:** Поведение кэша (ассоциативность, политика вытеснения) сильно зависит от микроархитектуры (Intel vs. AMD vs. ARM). Исследование будет сфокусировано на одной платформе (x86_64/Intel) с четким описанием ограничений.

3. **Интерпретация данных:** Основная исследовательская задача разработка эвристик и алгоритмов для перевода низкоуровневых кэш-событий в высокоуровневые поведенческие конструкции (цикл, вызов, переход).

---

## Технический стек и уровень реализации

С точки зрения исполнения, работа будет вестись на максимально низком уровне, необходимом для точного контроля времени и памяти. Ориентировочный стек:

- **Ядро анализатора:** C/C++ (для критичных к latency участков, для логики анализа), ассемблерные вставки (`rdtsc`, `clflush`, `mfence`).
- **Системное взаимодействие:** Системные вызовы Linux (`ptrace`, `process_vm_readv`), работа с `/proc/pid/maps`, управление планировщиком (`sched_setaffinity`, `isolcpus`).
- **Анализ бинарного файла:** Использование библиотек для дизассемблирования (например, **Capstone Engine**) и парсинга ELF (например, **LIEF** или **elfutils**).
- **Визуализация и скриптование:** Python или С+raylib для пост-обработки логов, построения графиков (matplotlib, seaborn) и создания скриптов-обвязки.

Этот выбор обусловлен необходимостью прямого доступа к аппаратным счетчикам, минимальными накладными расходами и полным контролем над памятью и исполнением. Прототип будет представлять собой связку из драйвера/агента-сборщика данных (на С) и набора скриптов/утилит анализа (на Python/C++).

---

## Ожидаемый результат и научная/практическая ценность

**Результат:** Это исследование. На выходе будет **методология** и **рабочий прототип** (или набор прототипов) под Linux/x86_64, доказывающий её жизнеспособность. Итогом может стать как скрипт для анализа конкретного вида обфускации, так и библиотека для сбора кэш-следов.

**Научная ценность:** Систематизация и развитие методов атак по сторонним каналам для новой прикладной задачи, для обратной разработки. Исследование устойчивости современных методов обфускации к такому виду анализа.

**Практическая ценность:** Создание инструментария и техник, которые могут стать критическим компонентом в арсенале специалиста по безопасности и реверс-инжинирингу при анализе сложного защищенного ПО (вредоносное ПО, коммерческие протекторы). Даже частичный успех даст новые возможности для анализа.
